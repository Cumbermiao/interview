<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <button id="click">click</button>
  <script>
    //1 输出结果
    if (true) return;
    async function async1() {
      console.log('async1 start');
      await async2();
      console.log('async1 end');
    }
    async function async2() {
      console.log('async2');
    }
    console.log('script start');
    setTimeout(function () {
      console.log('setTimeout');
    }, 0);
    async1().then(function () { console.log('async1 then') })
    new Promise(function (resolve) {
      console.log('promise1');
      resolve()
    }).then(function () {
      console.log('promise2');
    });
    console.log('script end');
  </script>

  <script>
    //2 修改错误并输出期望值
    const obj = {
      name: " jsCoder",
      skill: ["es6", "react", "angular"],
      say: function () {
        for (var i = 0, len = this.skill.length; i < len; i++) {
          setTimeout(function () {
            console.log("No." + i + this.name);
            console.log(this.skill[i]);
            console.log('----------------------')
          }, 0);
          console.log(i)
        }
      }
    }
    // obj.say();
  </script>

  <script>
    //3 实现 Function 原型的 bind方法， 输出 success
    function Animal(name, color) {
      this.name = name;
      this.color = color;
    }
    Animal.prototype.say = function () {
      return `I am a ${this.color} ${this.name}`;
    }

    const Cat = Animal.bind(null, 'cat');
    const cat = new Cat('white');

    if (cat.say() === 'I am a white cat' && cat instanceof Cat && cat instanceof Animal) {
      console.log('success');
    }
  </script>


  <script>
    //4 实现节流， 固定周期内只执行第一次触发
    // 节流与防抖的区别： 节流是固定周期内只执行第一次触发， 防抖是延迟函数执行，例如搜索，当用户输入结束一秒后再进行搜素， 只要用户输入间隔小于一秒那就一直触发延时， 直到超过1秒之后执行搜索。

    
  </script>

  <script>
    //5 从给定的无序、不重复的数组data 中， 取出n个数， 使其相加和为 sum 并给出算法的时间和空间复杂度
    function getResult(data, n, sum) { }

  </script>











  <!-- 答案 -->
  <script>
    //2
    // const obj = {
    //   name: " jsCoder",
    //   skill: ["es6", "react", "angular"],
    //   say: function () {
    //     for (let i = 0, len = this.skill.length; i < len; i++) {
    //       setTimeout(()=> {
    //         console.log("No." + i + this.name);
    //         console.log(this.skill[i]);
    //         console.log('----------------------')
    //       }, 0);
    //       console.log(i+1)
    //     }
    //   }
    // }

    // 3 省略了一些类型判断
    // Function.prototype.bind = function (bindthis, ...args) {
    //   var _this = this;
    //   var wrap = function () {
    //     /**
    //      * 关键点在于 如果是 new 调用的方式， wrap 中的 this 不能绑定在 bindthis 上， 应该绑在 wrap 实例上。
    //      * 由于 wrap 继承了被绑定函数的原型链， 使用 isPrototypeOf 可以判断出 wrap 中的 this 实例是否继承自被绑定函数。
    //      **/
    //     _this.apply(_this.prototype.isPrototypeOf(this) ? this : bindthis, [...args, ...arguments])
    //   }
    //   wrap.prototype = Object.create(_this.prototype)
    //   wrap.prototype.constructor = wrap;
    //   return wrap
    // }

    //  4 节流
    //   function throttle(fn, delay) {
    //   var now;
    //   return function () {
    //     if(now===undefined||new Date() - now > delay){
    //       fn();
    //       now = new Date();
    //     }
    //   }
    // }
    // 防抖
    // function debounce(fn,delay){
    //   var timer;
    //   return function(){
    //     if(timer)clearTimeout(timer);
    //     timer = setTimeout(function(){
    //       fn();
    //     },delay);
    //   }
    // }
    // window.addEventListener('click',debounce(()=>console.log('click'),2000))

    //5
    // function getResult(data, n, sum) {
    //   function backtracing(template, idx, arr, count, sum) {
    //     if (plus(template) === sum && template.length === n) return template
    //     if (idx >= arr.length || count < 0) return false;
    //     for (let i = idx; i < arr.length; i++) {
    //       var cpTemplate = [...template, arr[i]];
    //       var match = backtracing(cpTemplate, i + 1, arr, count - 1, sum);
    //       if (match) return match
    //     }
    //     return false
    //   }
    //   return backtracing([], 0, data, n, sum)
    // }
    // function plus(arr) {
    //   let res = 0;
    //   for (let i = 0; i < arr.length; i++) {
    //     res += arr[i]
    //   }
    //   return res
    // }
    // var data = [1, 2, 3, 4, 5, 6]
    // console.log(getResult(data, 3, 6))
  </script>
</body>

</html>